# Go Fuzz Testing Example

A practical demonstration of Go's native fuzz testing capabilities using a string reversal function. This project serves as a learning resource for my understanding on how fuzz testing works in Go and how it can help find bugs that traditional testing might miss.

## Project Overview

This project implements a simple string reversal function with comprehensive fuzz tests. It's designed to help developers understand:

- How to write fuzz tests in Go
- How fuzz testing generates test cases automatically
- How fuzz testing can edge cases and bugs
- The structure of a fuzz test corpus

## Key Components

### `Reverse(s string) (string, error)`
- **Purpose**: Reverses a string using UTF-8 aware rune operations
- **Features**: Includes UTF-8 validation to ensure proper character handling

### `FuzzReverse(f *testing.F)`
- **Purpose**: Fuzz test that validates the `Reverse` function
- **Seed Corpus**: Provides initial test cases: `"Hello, world"`, `" "`, `"!12345"`
- **Validation Rules**:
  - Double reversal should return the original string
  - Valid UTF-8 input should produce valid UTF-8 output

## Getting Started

### Prerequisites
- Go 1.18+ (fuzz testing was introduced in Go 1.18)

### Running the Example
```bash
go run .
```

### Running Tests

#### Regular Unit Tests
```bash
go test
```

#### Fuzz Testing
```bash
# Run fuzz tests (will run indefinitely until you stop it with Ctrl+C)
go test -fuzz=.

# Run fuzz tests with a time limit (e.g., 30 seconds)
go test -fuzz=. -fuzztime=30s

# Run fuzz tests with a specific number of iterations
go test -fuzz=. -fuzztime=1000x
```

#### Verbose Test Output
```bash
go test -v
go test -fuzz=. -v
```

## Learning Objectives

This project demonstrates several important concepts about fuzz testing:

### 1. **Automatic Test Case Generation**
Fuzz testing automatically generates random inputs to test your code, finding edge cases i might not think of.

### 2. **Invariant Testing**
The fuzz test verifies that reversing a string twice should return the original string - a classic invariant that helps catch logic errors.

### 3. **Property-Based Testing**
Instead of testing specific examples, fuzz testing tests properties that should hold true for all valid inputs.

### 4. **Crash Reproduction(this i love so much)**
When fuzz testing finds a failing input, it saves it to the corpus (`testdata/fuzz/FuzzReverse/`) so you can reproduce and fix the bug.

## Understanding the Fuzz Corpus

The `testdata/fuzz/FuzzReverse/` directory contains automatically generated test cases that previously caused failures. These files help:
- Reproduce bugs during development
- Ensure fixed bugs don't reoccur
- Provide valuable test cases for edge conditions

## The Fixed Bug

This project originally contained a subtle bug in the UTF-8 validation logic:

**Previous buggy code:**
```go
if utf8.ValidString(s) {
    return "", errors.New("Input is not a valid UTF-8")
}
```

**Issue**: The condition was inverted! It returned an error when the input WAS valid UTF-8, when it should do the opposite.

**Fixed code:**
```go
if !utf8.ValidString(s) {
    return "", errors.New("Input is not a valid UTF-8")
}
```

**How fuzz testing helped**: Fuzz testing quickly identified this issue by testing various string inputs and discovering that valid UTF-8 strings were incorrectly rejected. This demonstrates how fuzz testing can catch logic errors that might be missed in manual testing.

## Fuzz Testing Commands Reference

```bash
# Basic fuzz testing
go test -fuzz=FuzzReverse

# Fuzz with time limit
go test -fuzz=FuzzReverse -fuzztime=60s

# Fuzz with iteration limit  
go test -fuzz=FuzzReverse -fuzztime=10000x

# Continue fuzzing from existing corpus
go test -fuzz=FuzzReverse -fuzztime=30s

# Clean the fuzz corpus (start fresh)
go test -fuzz=FuzzReverse -fuzzclean
```

## Why Fuzz Testing?

Traditional unit tests use manually written test cases, which means you can only test what you think to test. Fuzz testing complements unit testing by:

- **Finding Edge Cases**: Testing inputs you wouldn't manually consider
- **Discovering Bugs**: Finding issues in edge conditions and error handling
- **Improving Robustness**: Making your code more resilient to unexpected inputs
- **Saving Time**: Automatically generating comprehensive test scenarios

## Resources

- [Go Fuzz Testing Documentation](https://go.dev/doc/fuzz/)
- [Effective Go Testing](https://go.dev/doc/effective_go#testing)

## Contributing

This is an educational project. Feel free to:
- Experiment with different fuzz test strategies
- Add more invariants to test
- Introduce new bugs and see how fuzz testing catches them



**this documentation was generated by ai**
